 Android调用so库（c语言编写） Codeblocks+adt-win-x86+ndk-r9c
分类： Android 2014-01-23 10:19 70人阅读 评论(0) 收藏 编辑 删除
Android CC++Android so
目录(?)[-]
所需软件环境
so库开发环境
Android客户端开发
环境搭建
CodeBlocks环境搭建
Android 开发环境搭建
SO库编写
生成头文件
编写SO库
Android编写
Android调用so库, so库是c语言编写

1. 所需软件环境：
1）so库开发环境
操作系统： Ubuntu 10.04  x86

编译软件：Code::Blocks

Android native开发库：android-ndk-r9c-linux-x86.tar.bz2 

2） Android客户端开发
操作系统：Windows 7 x86

测试环境： Android手机（系统4.0及以上）

开发工具和SDK包： adt-bundle-windows-x86-20131030.zip(里面含有Eclipse)

本文所需软件如下：

android-ndk-r9c-linux-x86.tar.bz2   http://developer.android.com/intl/zh-cn/tools/sdk/ndk/index.html
adt-bundle-windows-x86-20131030.zip   http://developer.android.com/intl/zh-cn/sdk/index.html
Code::Blocks  http://www.codeblocks.org/downloads/binaries
2. 环境搭建
1）Code::Blocks环境搭建
      首先安装Code::Blocks, 然后解压 android-ndk-r9c-linux-x86.tar.bz2 , 如解压到桌面  /home/UserName/Desktop/android-ndk-r9c/
      然后启动Code::Blocks,  进行系统环境配置

     1.1) 配置全局环境

           S1:  打开  Settings-> Compiler and debugger... 

           S2:  选择编译器Selected complier ->  GNU ARM GCC Complier，或自己新建一个

           S3:  选择 Toolchain executables

           S4:  设置android-ndk路径( Complier's installation directory ) ，如 /home/xxx/Desktop/android-ndk-r9c/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86

           S5:  设置Program Files各个编译程序

                  C complier:                       arm-linux-androideabi-gcc

                  C++ compiler:                  arm-linux-androideabi-g++

                  Linker for dynamic libs:  arm-linux-androideabi-g++

                  Linker for static libs:        arm-linux-androideabi-ar

                  Debugger:                         arm-linux-androideabi-gdb

                  Resource compiler:        

                 

           S6: 设置Additional Paths,  增加(Add)  :  /home/xxx/Desktop/android-ndk-r9c/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86/arm-linux-androideabi/bin

           S7: 设置 Search directories -> Compiler,  增加(Add)  : /home/xxx/Desktop/android-ndk-r9c/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86/include

           S8: 设置 Search directories -> Linker,

[cpp] view plaincopy
/home/xxx/Desktop/android-ndk-r9c/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86/lib  
/home/xxx/Desktop/android-ndk-r9c/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86/lib/gcc/arm-linux-androideabi/4.6  
/home/xxx/Desktop/android-ndk-r9c/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86/lib/gcc/arm-linux-androideabi/4.6/armv7-a  
              

           S9:  设置完成，点击确定

    1.2) 配置项目的环境

         S1:  右击项目，选择Build options,  Selected Complier选择刚才设置的那个  GUN ARM GCC Compiler 

         S2:  设置 Search directories -> Linker,  Add : 

[cpp] view plaincopy
/home/xxx/Desktop/android-ndk-r9c/platforms/android-14/arch-arm/usr/lib  

2）Android 开发环境搭建
     直接解压 adt-bundle-windows-x86-20131030.zip ， 如解压到  E:\Program Files\adt\adt-bundle-windows-x86-20131030 

     

     就可以看到里面以及放好了eclipse, 此处的eclipse默认已经配置好了 adt,  启动 eclipse.exe 配置android虚拟机

    菜单 Window -> Android Virtual Device Manager  管理虚拟机， Android SDK Manager 可以更新 SDK，由于此adt所带android系统是4.4,  建议再 更新 4.0.3 (

           手动更新详见： 手动下载Android开发SDK
                 sdk:platform -> https://dl-ssl.google.com/android/repository/android-14_r03.zip
                 sdk:system-image -> https://dl-ssl.google.com/android/repository/sysimg_armv7a-14_r02.zip  
     )

    如下图所示

    

    新建一个虚拟机

    

3. SO库编写
    1）生成头文件
        打开adt-bundle-windows里面的Eclipse

        新建Android项目JniTestAndroid ，建立包 com.lpr， 建类  JniTestAndroid

        JniTestAndroid.java

[java] view plaincopy在CODE上查看代码片派生到我的代码片
package com.lpr;  
class JniTestAndroid {  
    public native byte[]  recognition(short arr[]);  
      static {  
    System.loadLibrary("JniTestAndroid");//Load  JniTestAndroid.so  
    //  System.out.println(System.getProperty("java.library.path"));  
    //  System.setProperty("java.library.path", ".");  
      }  
}  

 用 Javac 编译成 class文件
>cd E:\JniTestAndroid
>javac com/lpr/JniTestAndroid.java
>javah com.lpr.JniTestAndroid
现在生成了 com_lpr_JniTestAndroid.h
[cpp] view plaincopy在CODE上查看代码片派生到我的代码片
/* DO NOT EDIT THIS FILE - it is machine generated */  
#include <jni.h>  
/* Header for class com_lpr_JniTestAndroid */  
  
#ifndef _Included_com_lpr_JniTestAndroid  
#define _Included_com_lpr_JniTestAndroid  
#ifdef __cplusplus  
extern "C" {  
#endif  
/* 
 * Class:     com_lpr_JniTestAndroid 
 * Method:    recognition 
 * Signature: ([S)[B 
 */  
JNIEXPORT jbyteArray JNICALL Java_com_lpr_JniTestAndroid_recognition  
  (JNIEnv *, jobject, jshortArray);  
  
#ifdef __cplusplus  
}  
#endif  
#endif  
现在将com_lpr_JniTestAndroid.h拷贝到 Ubuntu下面

并将 $java_home/include/jni.h 和 ./linux/jni_md.h 拷贝到 Ubuntu下面

在此特给出 jni_md.h 源码

[cpp] view plaincopy
#ifndef _JAVASOFT_JNI_MD_H_  
#define _JAVASOFT_JNI_MD_H_  
  
#define JNIEXPORT __declspec(dllexport)  
#define JNIIMPORT __declspec(dllimport)  
#define JNICALL   
  
typedef long jint;  
typedef __int64 jlong;  
typedef signed char jbyte;  
  
#endif /* !_JAVASOFT_JNI_MD_H_ */  
       2）编写SO库
             打开Code::Block新建项目 JniTestAndroid

             添加 com_lpr_JniTestAndroid.h, jni.h,  jni_md.h 到项目（不添加也可以，只要放到项目的更目录即可）

            main.cpp

           

[cpp] view plaincopy
#include "stdio.h"  
#include "com_lpr_JniTestAndroid.h"  
  
JNIEXPORT jbyteArray JNICALL Java_com_lpr_JniTestAndroid_recognition  
  (JNIEnv *jnienv, jobject jobj, jshortArray  shortArray)  
{  
    short*  iArray ; //=new short[maxSize];  
    jboolean jbool = true;  
    //转换数组  
    iArray = jnienv->GetShortArrayElements(shortArray, &jbool);  
    //...  
    //  
    jnienv->ReleaseShortArrayElements(shortArray,iArray,0);  
    // do something with iArray ...  
    char carnumber[64]={"北京123456"};  
    // carnumber;  
      
    jbyteArray  returnLPRArray = jnienv->NewByteArray( 64 );  
    jbyte *bytes = jnienv->GetByteArrayElements( returnLPRArray, 0);  
      
    int nLPRLen = strlen(nLPRLen);  
    //返回值最好是 byte,以免utf8造成汉字的影响  
    for ( int i = 0; i < nLPRLen;  i++ )  
    {  
        bytes[ i ] = carnumber[ i ];  
    }  
  
    jnienv->SetByteArrayRegion(returnLPRArray, 0, nLPRLen, bytes );  
      
    return   returnLPRArray ;  
}  
            

           几点注意：

            1. 如果传入参数或传出参数有汉字或比较复杂的机构，建议都化为 jbyteArray, 特别是有关的汉字问题


4. Android编写

QQ: 1505974441

持续更新中................................[2014.2.12 11:00:00]